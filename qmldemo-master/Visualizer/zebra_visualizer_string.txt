struct Material {
  vec4  ambient;
  vec4  diffuse;
  vec4  specular;
  float shininess;
};

struct LightBase {
  vec3  ambient;
  vec3  diffuse;
  vec3  specular;
};

struct Attenuation {
  float constant;
  float linear;
  float quadratic;
};

struct DirectionalLight {
  LightBase base;
  vec3      direction;
};

struct PointLight {
  LightBase    base;
  vec3         position;
  Attenuation  attenuation;
};

struct SpotLight {
  PointLight   pointlight; 
  vec3         direction;
  float        cutoff;
};

struct LightHeader {
  uint no_lights;
};
uniform DirectionalLights {
  LightHeader      info;
  DirectionalLight lights[10];
} u_directionallights;

uniform PointLights {
  LightHeader info;
  PointLight  lights[50];
} u_pointlights;

uniform SpotLights {
  LightHeader info;
  SpotLight   lights[50];
} u_spotlights;

vec3 
directionalLighting( DirectionalLight light, Material mat, vec3 frag_pos, vec3 N ) { 

  vec3 light_dir = normalize(-light.direction); 
  return mat.diffuse.rgb * light.base.ambient * max( dot( light_dir, N ), 0.0 ); 
}

float
luminosityFromAttenuation(PointLight light, vec3 frag_pos) {

  float dist = length( light.position- frag_pos ); 

  float constant  = light.attenuation.constant; 
  float linear    = light.attenuation.linear; 
  float quadratic = light.attenuation.quadratic; 

  return 
    constant +     linear * 1.0/dist +    quadratic * 1.0/(dist*dist);}

vec3
blinnPhongLighting( PointLight light, Material mat, vec3 frag_pos, vec3 N ) { 

  vec3 light_dir = normalize( light.position- frag_pos ); 

  float lambertian = max( dot( light_dir, N ), 0.0 ); 
  float specular = 0.0; 

  if(lambertian > 0.0) { 

    vec3 view_dir = normalize(-frag_pos); 
    vec3 half_dir = normalize(light_dir + view_dir); 
    float specular_angle = max( dot( half_dir, N ), 0.0 ); 
    specular = pow( specular_angle, mat.shininess ); 
  } 


  float luminosity = luminosityFromAttenuation(light,frag_pos);

  return 
    luminosity * (      mat.ambient.rgb * light.base.ambient + 
      mat.diffuse.rgb * light.base.diffuse * lambertian + 
      mat.specular.rgb * light.base.specular * specular 
    ); 
}

float
spotCutoffFactor(SpotLight light, vec3 frag_pos) {

  vec3 light_to_frag = normalize(frag_pos - light.pointlight.position); 
  vec3 spotlight_dir = normalize(light.direction); 

  float spot_fact = clamp( dot( light_to_frag, spotlight_dir ), 0.0, 1.0); 

  float cutoff_fact = 0.0; 

  if( spot_fact > light.cutoff ) {
    cutoff_fact = (spot_fact - light.cutoff) / (1.0 - light.cutoff); 
  }

  return cutoff_fact; 
}

vec3
correctGamma(vec3 linear_color, float screen_gamma) {

  return pow(linear_color, vec3(1.0/screen_gamma)); 
}

vec4
computeBlinnPhongLighting(Material mat, vec3 pos, vec3 normal ) {

  vec3 color = vec3(0);

  // Compute directional light contribution
  for( uint i = uint(0); i < u_directionallights.info.no_lights; ++i )
    color += directionalLighting( u_directionallights.lights[i], mat, pos, normal );

  // Compute pointlight contribution
  for( uint i = uint(0); i < u_pointlights.info.no_lights; ++i )
    color += blinnPhongLighting( u_pointlights.lights[i], mat, pos, normal );

  // Compute spotlight contribution
  for( uint i = uint(0); i < u_spotlights.info.no_lights; ++i )
    color += blinnPhongLighting( u_spotlights.lights[i].pointlight, mat, pos, normal ) * spotCutoffFactor( u_spotlights.lights[i], pos ); 

  return vec4(correctGamma(color.rgb,2.2),mat.diffuse.a);
}

uniform sampler2D u_nmap;
uniform mat4      u_mvmat;
uniform mat3      u_nmat;

uniform vec4      u_mat_amb;
uniform vec4      u_mat_dif;
uniform vec4      u_mat_spc;
uniform float     u_mat_shi;

smooth in vec3    ex_pos;
smooth in vec2    ex_tex;

out vec4 gl_FragColor;

void main() {

  vec3 nmap_normal = texture( u_nmap, ex_tex.ts).xyz;
  vec3 normal = normalize( u_nmat * nmap_normal );

  Material mat;
  mat.ambient   = u_mat_amb;
  mat.diffuse   = u_mat_dif;
  mat.specular  = u_mat_spc;
  mat.shininess = u_mat_shi;

  gl_FragColor = computeBlinnPhongLighting( mat, ex_pos, normal );

/*
float stripeWidth = 1.1;
   if(mod(ex_tex.x * (1.0/stripeWidth), 2.0) < 1.0){
       gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);
   }
*/

float stripeFrequency = 500;
float pattern = sin(ex_pos.y * stripeFrequency) /** sin(ex_pos.x * stripeFrequency)*/; //Horisontal stripes
//float pattern = sin(ex_pos.x * stripeFrequency + ex_pos.y * stripeFrequency); //Diagonal stripes
//float pattern = sin((length(vec2(ex_pos.x, ex_pos.y)) - 0.5) * stripeFrequency);  //Circles

float zebra = step(0.3, pattern);


gl_FragColor = vec4(vec3(zebra), 1.0);



}